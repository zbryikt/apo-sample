// Generated by LiveScript 1.3.1
var plotd3;
plotd3 = {
  html: {},
  rwd: {}
};
plotd3.html.popup = function(root, sel, cb){
  var popup, x$;
  popup = root.querySelector('.pdb-popup');
  if (!popup) {
    popup = d3.select(root).append('div').attr({
      'class': 'pdb-popup float'
    });
    popup.each(function(d, i){
      var x$;
      x$ = d3.select(this);
      x$.append('div').attr({
        'class': 'title'
      });
      x$.append('div').attr({
        'class': 'value'
      });
      return x$;
    });
  } else {
    popup = d3.select(popup);
  }
  x$ = sel;
  x$.on('mousemove', function(d, i){
    var ref$, x, y, pbox, rbox;
    ref$ = [d3.event.clientX, d3.event.clientY], x = ref$[0], y = ref$[1];
    cb.call(this, d, i, popup);
    popup.style({
      display: 'block'
    });
    pbox = popup[0][0].getBoundingClientRect();
    rbox = root.getBoundingClientRect();
    x = x - pbox.width / 2;
    y = y + 20;
    if (y > rbox.top + rbox.height - pbox.height - 50) {
      y = y - pbox.height - 40;
    }
    if (x < 10) {
      x = 10;
    }
    if (x > rbox.left + rbox.width - pbox.width - 10) {
      x = rbox.left + rbox.width - pbox.width - 10;
    }
    return popup.style({
      top: y + "px",
      left: x + "px"
    });
  });
  x$.on('mouseout', function(){
    if (sel.hidePopup) {
      clearTimeout(sel.hidePopup);
    }
    return sel.hidePopup = setTimeout(function(){
      return popup.style({
        display: 'none'
      });
    }, 1000);
  });
  return x$;
};
plotd3.rwd.legend = function(){
  var store, ret;
  store = {
    padding: 10
  };
  ret = function(){
    var that, data, x$, offset, max;
    store.group = this;
    if (that = store.tickValues) {
      data = that;
    } else if (!store.scale) {
      data = [0, 1];
    } else if (store.scale.invert) {
      data = store.scale.ticks(store.ticks || 5);
    } else {
      data = store.scale.domain();
    }
    x$ = this.selectAll('g.legend').data(data);
    x$.enter().append('g').attr({
      'class': 'legend'
    }).each(function(d, i){
      var node;
      node = d3.select(this);
      node.append('path').attr({
        'class': 'marker'
      });
      return node.append('text');
    });
    x$.exit().remove();
    this.selectAll('g.legend').each(function(d, i){
      var node, size, m;
      node = d3.select(this);
      node.select('text').text(d);
      size = node.select('text')[0][0].getBBox().height * 0.8;
      if (store.marker) {
        store.marker.call(node.select('path.marker')[0][0], d, i);
      } else {
        m = node.select('path.marker');
        m.attr({
          d: ("M" + size / 2 + " 0 A" + size / 2 + " " + size / 2 + " 0 0 0 " + size / 2 + " " + size) + ("A" + size / 2 + " " + size / 2 + " 0 0 0 " + size / 2 + " 0"),
          fill: store.scale(d)
        });
      }
      return node.select('text').attr({
        "dominant-baseline": "hanging",
        "text-anchor": "start",
        dy: 1,
        dx: size + 3
      });
    });
    offset = [0, 0];
    max = [0, 0];
    return this.selectAll('g.legend').each(function(d, i){
      var node, ref$, w, h;
      node = d3.select(this).attr({
        transform: "translate(" + offset[0] + " " + offset[1] + ")"
      });
      ref$ = [this.getBBox().width, this.getBBox().height], w = ref$[0], h = ref$[1];
      if ((ref$ = store.orient) === 'bottom' || ref$ === 'top') {
        if (store.size && store.size[0] < offset[0] + w) {
          offset[0] = 0;
          offset[1] += h + (store.padding[1] || 5);
          node = d3.select(this).attr({
            transform: "translate(" + offset[0] + " " + offset[1] + ")"
          });
        }
        return offset[0] += w + (store.padding[0] || 10);
      } else {
        if (max[0] < w) {
          max[0] = w;
        }
        if (store.size && store.size[1] < offset[1] + h) {
          offset[1] = 0;
          offset[0] += max[0] + (store.padding[0] || 10);
          node = d3.select(this).attr({
            transform: "translate(" + offset[0] + " " + offset[1] + ")"
          });
        }
        return offset[1] += h + (store.padding[1] || 5);
      }
    });
  };
  ret.offset = function(){
    var box;
    if (!store.group) {
      return [0, 0];
    }
    box = store.group[0][0].getBBox();
    return [box.width, box.height];
  };
  ['type', 'marker', 'tickValues', 'ticks', 'orient', 'scale', 'size', 'padding'].map(function(k){
    return ret[k] = function(k){
      return function(it){
        if (!it) {
          return store[k];
        }
        store[k] = it;
        return ret;
      };
    }(k);
  });
  return ret;
};
plotd3.rwd.axis = function(){
  var axis, ret, k, v;
  axis = d3.svg.axis();
  ret = function(){
    return ret.autotick(this, arguments);
  };
  for (k in axis) {
    v = axis[k];
    if (typeof v === 'function') {
      ret[k] = fn$(k);
    }
  }
  ret.offset = function(){
    return this._offset;
  };
  ret.autotick = function(group, args){
    var ref$, scale, orient, sizes, size, its, ots, tp, offset, format, tickHeight, count, ticks, step, gbox, pbox;
    args == null && (args = []);
    axis.apply(group, args);
    ref$ = [axis.scale(), axis.orient()], scale = ref$[0], orient = ref$[1];
    sizes = scale.range();
    size = sizes[1] - sizes[0];
    ref$ = [axis.innerTickSize(), axis.outerTickSize(), axis.tickPadding()], its = ref$[0], ots = ref$[1], tp = ref$[2];
    offset = d3.max([its, ots]) + tp + 1;
    format = axis.tickFormat();
    if (orient === 'left' || orient === 'right') {
      tickHeight = d3.max(group.selectAll('text')[0].map(function(d, i){
        return d.getBBox().height;
      }));
      count = size / (2 * tickHeight || 16);
      ticks = scale.ticks
        ? axis.tickValues() || scale.ticks(axis.ticks())
        : scale.domain();
      count = Math.ceil(ticks.length / count);
      ticks = ticks.filter(function(d, i){
        return !(i % count);
      });
      axis.tickValues(ticks);
      group.call(axis);
      this._offset = d3.max(group.selectAll('text')[0].map(function(d, i){
        return d.getBBox().width;
      }));
      this._offset += offset;
    } else {
      ticks = scale.ticks
        ? axis.tickValues() || scale.ticks(axis.ticks())
        : scale.domain();
      group.call(axis);
      step = 2 * d3.max(group.selectAll('text')[0].map(function(d, i){
        return d.getBBox().width;
      }));
      tickHeight = d3.max(group.selectAll('text')[0].map(function(d, i){
        return d.getBBox().height;
      }));
      count = Math.ceil(ticks.length / (size / step));
      ticks = ticks.filter(function(d, i){
        return !(i % count);
      });
      axis.tickValues(ticks);
      this._offset = tickHeight + offset;
    }
    if (group) {
      group.call(axis);
    }
    if (group && false) {
      gbox = group[0][0].getBBox();
      pbox = group.select('path')[0][0].getBBox();
      if (orient === 'left' || orient === 'right') {
        group.select('g.tick:first-of-type').attr({
          transform: function(){
            var origin;
            origin = d3.select(this).attr('transform');
            return origin + " translate(0 " + (-(pbox.y - gbox.y)) + ")";
          }
        });
        return group.select('g.tick:last-of-type').attr({
          transform: function(){
            var origin;
            origin = d3.select(this).attr('transform');
            return origin + " translate(0 " + (-((pbox.height - gbox.height) - (gbox.y - pbox.y))) + ")";
          }
        });
      } else if (orient === 'bottom' || orient === 'top') {
        group.select('g.tick:first-of-type').attr({
          transform: function(){
            var origin;
            origin = d3.select(this).attr('transform');
            return origin + " translate(" + (pbox.x - gbox.x) + " 0)";
          }
        });
        return group.select('g.tick:last-of-type').attr({
          transform: function(){
            var origin;
            origin = d3.select(this).attr('transform');
            return origin + " translate(" + ((pbox.width - gbox.width) - (gbox.x - pbox.x)) + " 0)";
          }
        });
      }
    }
  };
  return ret;
  function fn$(k){
    return function(){
      var r;
      r = axis[k].apply(axis, arguments);
      return r === axis ? ret : r;
    };
  }
};