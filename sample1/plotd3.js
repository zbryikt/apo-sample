// Generated by LiveScript 1.3.1
var plotd3;
plotd3 = {
  html: {},
  rwd: {}
};
plotd3.html.tooltip = function(root, sel, cb){
  var store, ret, popup;
  store = {
    handler: {}
  };
  ret = plotd3.html.popup(root, null, null, store);
  popup = store.popup;
  ret.nodes = function(sel){
    var x$;
    x$ = sel;
    x$.on('mousemove', function(d, i){
      var rbox, box, ref$, left, top, width, height, isLeft, update;
      rbox = d3.select(root)[0][0].getBoundingClientRect();
      box = this.getBoundingClientRect();
      if (store.coord) {
        ref$ = store.coord.call(this, d, i), left = ref$[0], top = ref$[1], width = ref$[2], height = ref$[3];
        box = {
          left: left,
          top: top,
          width: width,
          height: height
        };
      }
      ret.fire('mousemove', d, i, this);
      popup.attr({
        'class': "pdb-popup tooltip " + "left"
      });
      isLeft = box.left > rbox.width / 2 + rbox.left ? true : false;
      popup.attr({
        'class': "pdb-popup tooltip " + (isLeft ? 'left' : 'right')
      });
      update = function(){
        var pbox;
        pbox = popup[0][0].getBoundingClientRect();
        popup.style({
          top: (box.top + box.height / 2 - pbox.height / 2) + "px",
          opacity: 1
        });
        if (isLeft) {
          return popup.style({
            left: (box.left - pbox.width - 10) + "px"
          });
        } else {
          return popup.style({
            left: (box.left + box.width + 10) + "px"
          });
        }
      };
      if (popup.style("display") !== 'block') {
        popup.style({
          display: 'block',
          opacity: 0.01
        });
        return setTimeout(update, 0);
      } else {
        return update();
      }
    });
    x$.on('mouseout', function(d, i){
      ret.fire('mouseout', d, i, this);
      return popup.style({
        display: 'none'
      });
    });
    return ret;
  };
  ret.direction = function(it){
    store.direction = it === 'left' ? 'left' : 'right';
    return popup.attr({
      'class': "pdb-popup tooltip " + store.direction
    });
  };
  ret.show = function(x, y){
    var bbox;
    bbox = popup[0][0].getBoundingClientRect();
    if (store.direction !== 'right') {
      x = x - (bbox.right - bbox.left) - 10;
    } else {
      x = x + 10;
    }
    popup.style({
      display: 'block'
    });
    popup.style({
      top: (y - (bbox.bottom - bbox.top) / 2) + "px",
      left: x + "px"
    });
    return ret.hide();
  };
  ret.type('tooltip');
  return ret;
};
plotd3.html.float = function(root, sel, cb){
  var ret;
  ret = plotd3.html.popup(root, sel, cb);
  ret.type('float');
  return ret;
};
plotd3.html.popup = function(root, sel, cb, store){
  var popup, ret;
  store == null && (store = {
    handler: {}
  });
  popup = store.popup = d3.select(root).append('div');
  popup.each(function(d, i){
    var x$;
    x$ = d3.select(this);
    x$.append('div').attr({
      'class': 'title'
    });
    x$.append('div').attr({
      'class': 'value'
    });
    return x$;
  });
  popup.on('mouseover', function(){
    return d3.select(this).style({
      display: 'none'
    });
  });
  ret = function(){};
  ret.hide = function(d, i){
    if (d != null && i != null) {
      ret.fire('mouseout', d, i, this);
    }
    if (ret.hidePopup) {
      clearTimeout(ret.hidePopup);
    }
    return ret.hidePopup = setTimeout(function(){
      return popup.style({
        display: 'none'
      });
    }, 1000);
  };
  ret.getPopupNode = function(){
    return popup;
  };
  ret.nodes = function(sel){
    var x$;
    x$ = sel;
    x$.on('mouseout', ret.hide);
    x$.on('mousemove', function(d, i){
      var ref$, x, y, width, height, pbox, rbox;
      ref$ = [d3.event.clientX, d3.event.clientY], x = ref$[0], y = ref$[1];
      if (store.coord) {
        ref$ = store.coord.call(this, d, i), x = ref$[0], y = ref$[1], width = ref$[2], height = ref$[3];
      }
      ret.fire('mousemove', d, i, this);
      popup.style({
        display: 'block'
      });
      pbox = popup[0][0].getBoundingClientRect();
      rbox = root.getBoundingClientRect();
      x = x - pbox.width / 2 - rbox.left;
      y = y + 20 - rbox.top;
      if (y > rbox.height - pbox.height - 50) {
        y = y - pbox.height - 40;
      }
      if (x < 10) {
        x = 10;
      }
      if (x > +rbox.width - pbox.width - 10) {
        x = rbox.width - pbox.width - 10;
      }
      return popup.style({
        top: y + "px",
        left: x + "px"
      });
    });
    return ret;
  };
  ret.coord = function(cb){
    if (cb != null) {
      store.coord = cb;
    } else {
      return store.coord;
    }
    return ret;
  };
  ret.call = function(cb){
    return cb.call(popup[0][0]);
  };
  ret.show = function(x, y){
    popup.style({
      display: 'block'
    });
    popup.style({
      top: y + "px",
      left: x + "px"
    });
    return ret.hide();
  };
  ret.fire = function(event, d, i, node){
    var ref$;
    return ((ref$ = store.handler)[event] || (ref$[event] = [])).forEach(function(cb){
      return cb.call(node, d, i, popup);
    });
  };
  ret.fontSize = function(fs){
    if (fs != null) {
      store.fontSize = fs;
      popup.style({
        "font-size": fs + "px"
      });
      return ret;
    } else {
      return store.fontSize;
    }
  };
  ret.on = function(event, cb){
    var ref$;
    ((ref$ = store.handler)[event] || (ref$[event] = [])).push(cb);
    return ret;
  };
  ret.type = function(type){
    var that;
    if (!type) {
      return store.type;
    }
    store.type = type;
    return popup.attr({
      'class': ("pdb-popup " + ((that = store.type) ? that : "")).trim()
    });
  };
  if (sel) {
    ret.nodes(sel);
  }
  if (cb) {
    ret.on('mousemove', cb);
  }
  ret.type('float');
  return ret;
};
plotd3.rwd.legend = function(){
  var store, ret;
  store = {
    padding: [10, 5]
  };
  ret = function(){
    var that, data, x$, offset, max, label, ref$;
    store.group = this;
    if (that = store.tickValues) {
      data = that;
    } else if (!store.scale) {
      data = [0, 1];
    } else if (store.scale.invert) {
      data = store.scale.ticks(store.ticks || 5);
    } else {
      data = store.scale.domain();
    }
    x$ = this.selectAll('g.legend').data(data);
    x$.enter().append('g').attr({
      'class': 'legend'
    }).each(function(d, i){
      var node;
      node = d3.select(this);
      node.append('path').attr({
        'class': 'marker'
      });
      return node.append('text');
    });
    x$.exit().remove();
    this.selectAll('g.legend').each(function(d, i){
      var node, x$, size, m, r, dx;
      if (store.type === 'radius' && !d) {
        return;
      }
      node = d3.select(this);
      x$ = node.select('text');
      x$.text(d);
      if (store.fontSize != null) {
        x$.attr("font-size", store.fontSize);
      }
      size = node.select('text')[0][0].getBBox().height * 0.8;
      if (store.marker) {
        store.marker.call(node.select('path.marker')[0][0], d, i);
      } else {
        m = node.select('path.marker');
        if ((store.type || 'color') === 'color') {
          m.attr({
            d: ("M" + size / 2 + " 0 A" + size / 2 + " " + size / 2 + " 0 0 0 " + size / 2 + " " + size) + ("A" + size / 2 + " " + size / 2 + " 0 0 0 " + size / 2 + " 0"),
            fill: store.scale(d)
          });
        } else if (store.type === 'radius') {
          r = store.scale(d);
          m.attr({
            cx: r,
            cy: r,
            r: r,
            d: ("M" + size / 2 + " " + (size / 2 - r) + " A" + r + " " + r + " 0 0 0 " + size / 2 + " " + (size / 2 + r)) + ("A" + r + " " + r + " 0 0 0 " + size / 2 + " " + (size / 2 - r)),
            fill: '#999'
          });
        }
      }
      dx = 0;
      if (store.type === 'radius') {
        dx = store.scale(data[data.length - 1]);
      }
      return node.select('text').attr({
        "dominant-baseline": "hanging",
        "text-anchor": "start",
        dy: 1,
        dx: size + 3 + dx,
        "font-size": store.fontSize != null ? store.fontSize : void 8
      });
    });
    offset = [0, 0];
    max = [0, 0];
    this.select('text.label').remove();
    if (store.label) {
      label = this.append('text').attr({
        'class': 'label'
      }).text(store.label);
      label.attr({
        "font-size": store.fontSize != null ? store.fontSize * 1.1 : void 8,
        "font-weight": 'bold',
        "dominant-baseline": 'hanging'
      });
      if ((ref$ = store.orient) === 'bottom' || ref$ === 'top') {
        offset[0] += label[0][0].getBBox().width + store.padding[0] || 10;
      } else {
        offset[1] += label[0][0].getBBox().height + store.padding[1] || 5;
      }
    }
    return this.selectAll('g.legend').each(function(d, i){
      var node, ref$, w, h;
      node = d3.select(this).attr({
        transform: "translate(" + offset[0] + " " + offset[1] + ")"
      });
      ref$ = [this.getBBox().width, this.getBBox().height], w = ref$[0], h = ref$[1];
      if ((ref$ = store.orient) === 'bottom' || ref$ === 'top') {
        if (store.size && store.size[0] < offset[0] + w) {
          offset[0] = 0;
          offset[1] += h + (store.padding[1] || 5);
          node = d3.select(this).attr({
            transform: "translate(" + offset[0] + " " + offset[1] + ")"
          });
        }
        return offset[0] += w + (store.padding[0] || 10);
      } else {
        if (max[0] < w) {
          max[0] = w;
        }
        if (store.size && store.size[1] < offset[1] + h) {
          offset[1] = 0;
          offset[0] += max[0] + (store.padding[0] || 10);
          node = d3.select(this).attr({
            transform: "translate(" + offset[0] + " " + offset[1] + ")"
          });
        }
        offset[1] += h + (store.padding[1] || 5);
        return offset[1] += store.type === 'radius' ? 3 : 0;
      }
    });
  };
  ret.offset = function(){
    var box;
    if (!store.group) {
      return [0, 0];
    }
    box = store.group[0][0].getBBox();
    return [box.width, box.height];
  };
  ['label', 'fontSize', 'type', 'marker', 'tickValues', 'ticks', 'orient', 'scale', 'size', 'padding'].map(function(k){
    return ret[k] = function(k){
      return function(it){
        if (!it) {
          return store[k];
        }
        store[k] = it;
        return ret;
      };
    }(k);
  });
  return ret;
};
plotd3.rwd.axis = function(){
  var store, axis, ret, k, v, render;
  store = {};
  axis = d3.svg.axis();
  ret = function(){
    return ret.autotick(this, arguments);
  };
  for (k in axis) {
    v = axis[k];
    if (typeof v === 'function') {
      ret[k] = fn$(k);
    }
  }
  ret.offset = function(){
    return this._offset;
  };
  render = function(group, sizes, offset, orient){
    var mid, node;
    mid = (sizes[0] + sizes[1]) / 2;
    group.select('text.label').remove();
    group.call(axis);
    group.selectAll('text').attr({
      "font-size": store.fontSize != null ? store.fontSize : void 8
    });
    if (orient === 'bottom') {
      setTimeout(function(){
        return group.selectAll('.tick text').attr({
          "dy": "0.71em"
        });
      }, 0);
    }
    if (store.label) {
      node = group.append('text').attr({
        'class': 'label'
      }).text(store.label);
      if (store.fontSize != null) {
        node.attr({
          "font-size": store.fontSize
        });
      }
      if (orient === 'bottom' || orient === 'top') {
        if (store.labelPosition === 'in') {
          return node.attr({
            transform: "translate(" + sizes[1] + " -3)",
            "text-anchor": "end"
          });
        } else {
          return node.attr({
            transform: "translate(" + mid + " " + (offset + 5) + ")",
            "text-anchor": "middle"
          });
        }
      } else {
        if (store.labelPosition === 'in') {
          return node.attr({
            transform: "translate(0 " + sizes[0] + ") rotate(-90)",
            dy: "1em",
            "text-anchor": "end"
          });
        } else {
          return node.attr({
            transform: "translate(" + (-offset - 5) + " " + mid + ") rotate(-90)",
            "text-anchor": "middle"
          });
        }
      }
    }
  };
  ret.autotick = function(group, args){
    var ref$, scale, orient, sizes, size, its, ots, tp, offset, format, ticks, tickHeight, count, step, gbox, pbox;
    args == null && (args = []);
    axis.apply(group, args);
    ref$ = [axis.scale(), axis.orient()], scale = ref$[0], orient = ref$[1];
    if (scale.rangeExtent) {
      sizes = scale.rangeExtent();
    } else {
      sizes = scale.range();
      sizes = [sizes[0], sizes[1]];
      sizes.sort(function(a, b){
        return a - b;
      });
    }
    size = Math.abs(sizes[1] - sizes[0]);
    ref$ = [axis.innerTickSize(), axis.outerTickSize(), axis.tickPadding()], its = ref$[0], ots = ref$[1], tp = ref$[2];
    offset = d3.max([its, ots]) + tp + 1;
    format = axis.tickFormat();
    ticks = scale.ticks
      ? axis.tickValues() || scale.ticks(axis.ticks())
      : scale.domain();
    if (orient === 'left' || orient === 'right') {
      tickHeight = d3.max(group.selectAll('.tick text')[0].map(function(d, i){
        return d.getBBox().height;
      }));
      count = size / (1.4 * tickHeight || 14);
      count = Math.ceil(ticks.length / count);
      ticks = ticks.filter(function(d, i){
        return !(i % count);
      });
      axis.tickValues(ticks);
      render(group, sizes, offset, orient);
      this._offset = d3.max(group.selectAll('.tick text')[0].map(function(d, i){
        return d.getBBox().width;
      }));
      this._offset += offset;
    } else {
      render(group, sizes, offset, orient);
      step = 1.15 * d3.max(group.selectAll('.tick text')[0].map(function(d, i){
        return d.getBBox().width;
      }));
      tickHeight = d3.max(group.selectAll('.tick text')[0].map(function(d, i){
        return d.getBBox().height;
      }));
      count = Math.ceil(ticks.length / (size / step));
      ticks = ticks.filter(function(d, i){
        return !(i % count);
      });
      axis.tickValues(ticks);
      this._offset = tickHeight + offset;
    }
    render(group, sizes, this._offset, orient);
    if (store.label && store.labelPosition !== 'in') {
      this._offset += group.select('text.label')[0][0].getBBox().height + 5;
    }
    if (store.boundaryTickInside) {
      gbox = group[0][0].getBBox();
      pbox = group.select('path')[0][0].getBBox();
      if (orient === 'left' || orient === 'right') {
        group.select('g.tick:first-of-type text').attr({
          dy: -store.fontSize / 2
        });
        return group.select('g.tick:last-of-type text').attr({
          dy: store.fontSize
        });
      } else if (orient === 'bottom' || orient === 'top') {
        group.select('g.tick:first-of-type text').style({
          "text-anchor": 'start'
        });
        return group.select('g.tick:last-of-type text').style({
          "text-anchor": 'end'
        });
      }
    }
  };
  ['fontSize', 'label', 'labelPosition', 'multiLine', 'boundaryTickInside'].map(function(k){
    return ret[k] = function(k){
      return function(it){
        if (it == null) {
          return store[k];
        }
        store[k] = it;
        return ret;
      };
    }(k);
  });
  return ret;
  function fn$(k){
    return function(){
      var r;
      r = axis[k].apply(axis, arguments);
      return r === axis ? ret : r;
    };
  }
};